---
import { BookOpen, Menu, X, Search, ChevronLeft, ChevronUp, ChevronDown, AArrowUp } from "lucide-astro";

interface Props {
	title: string;
}

const { title } = Astro.props;
---

<header
	id="mobileHeader"
	class="fixed top-0 left-0 right-0 z-50 bg-amber-50/95 dark:bg-gray-900/95 backdrop-blur-sm border-b border-stone-300 dark:border-gray-700 shadow-md transition-transform duration-300 md:left-72"
>
	<!-- Vista normal del header -->
	<div id="headerNormal" class="flex items-center justify-between px-4 py-3">
		<!-- Botones a la izquierda -->
		<div class="absolute left-3 flex items-center gap-2">
			<button
				id="searchToggle"
				class="bg-amber-600/90 text-white p-2.5 rounded-full shadow-lg hover:bg-amber-700 transition"
				aria-label="Buscar en el libro"
				title="Buscar"
			>
				<Search class="h-5 w-5" />
			</button>
			<!-- Botón tamaño de texto -->
			<button
				id="fontSizeToggle"
				class="bg-amber-600/90 text-white p-2.5 rounded-full shadow-lg hover:bg-amber-700 transition"
				aria-label="Cambiar tamaño de texto"
				title="Tamaño de texto"
			>
				<AArrowUp class="h-5 w-5" />
			</button>
		</div>

		<!-- Título del libro y capítulo centrado -->
		<h1 class="flex-1 text-center text-lg md:text-xl font-bold text-gray-800 dark:text-gray-100 truncate px-12">
			{title} <span id="currentChapterDisplay" class="text-amber-700 dark:text-amber-400"></span>
		</h1>

		<!-- Controles a la derecha -->
		<div class="absolute right-3 flex items-center gap-2">
			<!-- Botón navegación de capítulos -->
			<button
				id="chapterNavToggle"
				class="bg-amber-600/90 text-white p-2.5 rounded-full shadow-lg hover:bg-amber-700 transition"
				aria-label="Navegar capítulos"
				title="Ir a capítulo"
			>
				<BookOpen class="h-5 w-5" />
			</button>

			<!-- Botón menú móvil (oculto en desktop) -->
			<button
				id="menuToggle"
				class="md:hidden bg-amber-700/90 text-white p-2.5 rounded-full shadow-lg hover:bg-amber-800 transition"
				aria-label="Abrir menú"
			>
				<Menu id="menuIcon" class="h-5 w-5" />
				<X id="closeIcon" class="h-5 w-5 hidden" />
			</button>
		</div>
	</div>

	<!-- Vista de búsqueda expandida -->
	<div id="headerSearch" class="hidden flex items-center gap-2 px-3 py-2">
		<!-- Botón volver -->
		<button
			id="searchClose"
			class="text-gray-600 dark:text-gray-300 p-2 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-full transition"
			aria-label="Cerrar búsqueda"
		>
			<ChevronLeft class="h-5 w-5" />
		</button>

		<!-- Input de búsqueda -->
		<div class="flex-1 relative">
			<input
				type="text"
				id="searchInput"
				placeholder="Buscar en este libro..."
				class="w-full px-4 py-2 pr-10 rounded-full bg-white dark:bg-gray-800 border border-stone-300 dark:border-gray-600 text-gray-800 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent"
			/>
			<Search class="absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
		</div>

		<!-- Navegación de resultados -->
		<div id="searchNavigation" class="hidden flex items-center gap-1">
			<span id="searchCount" class="text-xs text-gray-600 dark:text-gray-400 whitespace-nowrap"></span>
			<button
				id="searchPrev"
				class="text-gray-600 dark:text-gray-300 p-1.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-full transition"
				aria-label="Resultado anterior"
			>
				<ChevronUp class="h-4 w-4" />
			</button>
			<button
				id="searchNext"
				class="text-gray-600 dark:text-gray-300 p-1.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-full transition"
				aria-label="Siguiente resultado"
			>
				<ChevronDown class="h-4 w-4" />
			</button>
		</div>
	</div>
</header>

<script>
	function initSearch() {
		const searchToggle = document.getElementById('searchToggle');
		const searchClose = document.getElementById('searchClose');
		const headerNormal = document.getElementById('headerNormal');
		const headerSearch = document.getElementById('headerSearch');
		const searchInput = document.getElementById('searchInput') as HTMLInputElement;
		const searchNavigation = document.getElementById('searchNavigation');
		const searchCount = document.getElementById('searchCount');
		const searchPrev = document.getElementById('searchPrev');
		const searchNext = document.getElementById('searchNext');

		let searchResults: Element[] = [];
		let currentResultIndex = 0;
		let originalContent: Map<Element, string> = new Map();

		// Abrir búsqueda
		searchToggle?.addEventListener('click', () => {
			headerNormal?.classList.add('hidden');
			headerSearch?.classList.remove('hidden');
			headerSearch?.classList.add('flex');
			searchInput?.focus();
		});

		// Cerrar búsqueda
		searchClose?.addEventListener('click', closeSearch);

		function closeSearch() {
			headerSearch?.classList.add('hidden');
			headerSearch?.classList.remove('flex');
			headerNormal?.classList.remove('hidden');
			clearHighlights();
			if (searchInput) searchInput.value = '';
			searchNavigation?.classList.add('hidden');
			searchNavigation?.classList.remove('flex');
		}

		// Limpiar highlights anteriores
		function clearHighlights() {
			document.querySelectorAll('.search-highlight').forEach(el => {
				const parent = el.parentNode;
				if (parent) {
					parent.replaceChild(document.createTextNode(el.textContent || ''), el);
					parent.normalize();
				}
			});
			searchResults = [];
			currentResultIndex = 0;
		}

		// Buscar texto
		function performSearch(query: string) {
			clearHighlights();

			if (!query || query.length < 2) {
				searchNavigation?.classList.add('hidden');
				searchNavigation?.classList.remove('flex');
				return;
			}

			const bibleContent = document.querySelector('.bible-content');
			if (!bibleContent) return;

			// Buscar en el contenido de la biblia
			const walker = document.createTreeWalker(
				bibleContent,
				NodeFilter.SHOW_TEXT,
				{
					acceptNode: (node) => {
						// Excluir nodos dentro de scripts, styles, etc.
						const parent = node.parentElement;
						if (!parent) return NodeFilter.FILTER_REJECT;
						const tagName = parent.tagName.toLowerCase();
						if (['script', 'style', 'noscript'].includes(tagName)) {
							return NodeFilter.FILTER_REJECT;
						}
						return NodeFilter.FILTER_ACCEPT;
					}
				}
			);

			const textNodes: Text[] = [];
			let node: Node | null;
			while ((node = walker.nextNode())) {
				textNodes.push(node as Text);
			}

			textNodes.forEach(textNode => {
				const text = textNode.textContent || '';
				const matches = findFlexibleMatches(text, query);

				if (matches.length > 0) {
					const fragment = document.createDocumentFragment();
					let lastIndex = 0;

					matches.forEach(match => {
						// Texto antes del match
						if (match.start > lastIndex) {
							fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.start)));
						}
						// El match resaltado
						const mark = document.createElement('mark');
						mark.className = 'search-highlight bg-yellow-300 dark:bg-yellow-600 rounded px-0.5';
						mark.textContent = text.slice(match.start, match.end);
						fragment.appendChild(mark);
						lastIndex = match.end;
					});

					// Texto restante después del último match
					if (lastIndex < text.length) {
						fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
					}

					textNode.parentNode?.replaceChild(fragment, textNode);
				}
			});

			// Recoger todos los highlights
			searchResults = Array.from(document.querySelectorAll('.search-highlight'));

			if (searchResults.length > 0) {
				searchNavigation?.classList.remove('hidden');
				searchNavigation?.classList.add('flex');
				currentResultIndex = 0;
				updateSearchCount();
				scrollToResult(0);
			} else {
				searchNavigation?.classList.add('hidden');
				searchNavigation?.classList.remove('flex');
			}
		}

		function escapeRegExp(string: string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		}

		// Normalizar texto: quita tildes, comas y otros signos de puntuación
		function normalizeText(text: string): string {
			return text
				.normalize('NFD')
				.replace(/[\u0300-\u036f]/g, '') // Quita tildes
				.replace(/[,;:.!?¡¿'"«»""'']/g, '') // Quita puntuación
				.toLowerCase();
		}

		// Buscar coincidencias flexibles (sin importar tildes ni puntuación)
		function findFlexibleMatches(text: string, query: string): { start: number; end: number }[] {
			const normalizedText = normalizeText(text);
			const normalizedQuery = normalizeText(query);
			const matches: { start: number; end: number }[] = [];

			if (!normalizedQuery) return matches;

			let searchStart = 0;
			while (true) {
				const foundIndex = normalizedText.indexOf(normalizedQuery, searchStart);
				if (foundIndex === -1) break;

				// Encontrar los índices correspondientes en el texto original
				// Necesitamos mapear desde el texto normalizado al original
				let originalStart = 0;
				let normalizedCount = 0;

				// Encontrar el inicio en el texto original
				for (let i = 0; i < text.length && normalizedCount < foundIndex; i++) {
					const char = text[i];
					const normalizedChar = normalizeText(char);
					if (normalizedChar.length > 0) {
						normalizedCount++;
					}
					originalStart = i + 1;
				}

				// Encontrar el final en el texto original
				let originalEnd = originalStart;
				let matchedLength = 0;
				for (let i = originalStart; i < text.length && matchedLength < normalizedQuery.length; i++) {
					const char = text[i];
					const normalizedChar = normalizeText(char);
					if (normalizedChar.length > 0) {
						matchedLength++;
					}
					originalEnd = i + 1;
				}

				matches.push({ start: originalStart, end: originalEnd });
				searchStart = foundIndex + 1;
			}

			return matches;
		}

		function updateSearchCount() {
			if (searchCount) {
				searchCount.textContent = `${currentResultIndex + 1}/${searchResults.length}`;
			}
			// Marcar el resultado actual
			searchResults.forEach((el, i) => {
				if (i === currentResultIndex) {
					el.classList.add('ring-2', 'ring-amber-500');
				} else {
					el.classList.remove('ring-2', 'ring-amber-500');
				}
			});
		}

		function scrollToResult(index: number) {
			if (searchResults[index]) {
				searchResults[index].scrollIntoView({
					behavior: 'smooth',
					block: 'center'
				});
				updateSearchCount();
			}
		}

		// Evento de búsqueda con debounce
		let searchTimeout: ReturnType<typeof setTimeout>;
		searchInput?.addEventListener('input', (e) => {
			clearTimeout(searchTimeout);
			searchTimeout = setTimeout(() => {
				performSearch((e.target as HTMLInputElement).value);
			}, 300);
		});

		// Navegación entre resultados
		searchPrev?.addEventListener('click', () => {
			if (searchResults.length > 0) {
				currentResultIndex = (currentResultIndex - 1 + searchResults.length) % searchResults.length;
				scrollToResult(currentResultIndex);
			}
		});

		searchNext?.addEventListener('click', () => {
			if (searchResults.length > 0) {
				currentResultIndex = (currentResultIndex + 1) % searchResults.length;
				scrollToResult(currentResultIndex);
			}
		});

		// Cerrar con Escape
		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape' && !headerSearch?.classList.contains('hidden')) {
				closeSearch();
			}
			// Enter para siguiente resultado
			if (e.key === 'Enter' && document.activeElement === searchInput) {
				e.preventDefault();
				if (searchResults.length > 0) {
					currentResultIndex = (currentResultIndex + 1) % searchResults.length;
					scrollToResult(currentResultIndex);
				}
			}
		});
	}

	// Inicializar en carga
	document.addEventListener('DOMContentLoaded', initSearch);
	document.addEventListener('astro:page-load', initSearch);

	// Control de tamaño de texto
	let fontSizeInitialized = false;

	function initFontSize() {
		// Evitar inicialización múltiple
		if (fontSizeInitialized && document.getElementById('fontSizePanel')) {
			const bibleContent = document.querySelector('.bible-content');
			const savedSize = localStorage.getItem('bibleFontSize') || 'medium';
			const fontSizes: Record<string, string> = {
				small: 'text-sm',
				medium: 'text-base',
				large: 'text-lg',
				xlarge: 'text-xl'
			};
			if (bibleContent) {
				Object.values(fontSizes).forEach(cls => bibleContent.classList.remove(cls));
				bibleContent.classList.add(fontSizes[savedSize] || fontSizes.medium);
			}
			return;
		}

		fontSizeInitialized = true;

		const fontSizeToggle = document.getElementById('fontSizeToggle');
		const bibleContent = document.querySelector('.bible-content');

		const fontSizes: Record<string, string> = {
			small: 'text-sm',
			medium: 'text-base',
			large: 'text-lg',
			xlarge: 'text-xl'
		};

		// Crear el panel dinámicamente
		let fontSizePanel = document.getElementById('fontSizePanel');

		if (!fontSizePanel) {
			fontSizePanel = document.createElement('div');
			fontSizePanel.id = 'fontSizePanel';
			fontSizePanel.setAttribute('style', 'position: fixed; background: white; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); border: 1px solid #d1d5db; padding: 12px; min-width: 160px; z-index: 9999; display: none;');
			fontSizePanel.innerHTML = `
				<p style="font-size: 12px; color: #6b7280; margin-bottom: 8px; font-weight: 500;">Tamaño de texto</p>
				<div style="display: flex; flex-direction: column; gap: 4px;">
					<button class="font-size-option" data-size="small" style="text-align: left; padding: 6px 12px; border-radius: 4px; border: none; background: transparent; cursor: pointer; color: #374151; font-size: 14px;">
						<span style="font-size: 12px; font-weight: bold; margin-right: 8px;">A</span> Pequeño
					</button>
					<button class="font-size-option" data-size="medium" style="text-align: left; padding: 6px 12px; border-radius: 4px; border: none; background: transparent; cursor: pointer; color: #374151;">
						<span style="font-size: 16px; font-weight: bold; margin-right: 8px;">A</span> Mediano
					</button>
					<button class="font-size-option" data-size="large" style="text-align: left; padding: 6px 12px; border-radius: 4px; border: none; background: transparent; cursor: pointer; color: #374151;">
						<span style="font-size: 18px; font-weight: bold; margin-right: 8px;">A</span> Grande
					</button>
					<button class="font-size-option" data-size="xlarge" style="text-align: left; padding: 6px 12px; border-radius: 4px; border: none; background: transparent; cursor: pointer; color: #374151;">
						<span style="font-size: 20px; font-weight: bold; margin-right: 8px;">A</span> Muy grande
					</button>
				</div>
			`;
			document.body.appendChild(fontSizePanel);
		}

		const fontSizeOptions = fontSizePanel.querySelectorAll('.font-size-option');

		// Cargar tamaño guardado
		const savedSize = localStorage.getItem('bibleFontSize') || 'medium';
		applyFontSize(savedSize);
		updateActiveOption(savedSize);

		// Toggle panel - usar variable para controlar estado
		let panelOpen = false;

		if (fontSizeToggle && !fontSizeToggle.hasAttribute('data-initialized')) {
			fontSizeToggle.setAttribute('data-initialized', 'true');

			fontSizeToggle.addEventListener('click', (e) => {
				e.stopPropagation();
				e.preventDefault();

				panelOpen = !panelOpen;

				if (panelOpen) {
					const rect = fontSizeToggle.getBoundingClientRect();
					fontSizePanel!.style.top = `${rect.bottom + 8}px`;
					fontSizePanel!.style.left = `${rect.left}px`;
					fontSizePanel!.style.display = 'block';
				} else {
					fontSizePanel!.style.display = 'none';
				}
			});

			// Cerrar panel al hacer clic fuera - solo una vez
			document.addEventListener('click', (e) => {
				const target = e.target as Node;
				if (panelOpen && fontSizePanel && !fontSizePanel.contains(target) && target !== fontSizeToggle && !fontSizeToggle.contains(target)) {
					fontSizePanel.style.display = 'none';
					panelOpen = false;
				}
			});
		}

		// Opciones de tamaño
		fontSizeOptions.forEach(option => {
			if (!option.hasAttribute('data-initialized')) {
				option.setAttribute('data-initialized', 'true');
				option.addEventListener('click', (e) => {
					e.stopPropagation();
					const size = (option as HTMLElement).dataset.size || 'medium';
					applyFontSize(size);
					updateActiveOption(size);
					localStorage.setItem('bibleFontSize', size);
					fontSizePanel!.style.display = 'none';
					panelOpen = false;
				});
			}
		});

		function applyFontSize(size: string) {
			if (!bibleContent) return;
			Object.values(fontSizes).forEach(cls => bibleContent.classList.remove(cls));
			bibleContent.classList.add(fontSizes[size] || fontSizes.medium);
		}

		function updateActiveOption(size: string) {
			fontSizeOptions.forEach(option => {
				const optionSize = (option as HTMLElement).dataset.size;
				if (optionSize === size) {
					(option as HTMLElement).style.background = '#fde68a';
				} else {
					(option as HTMLElement).style.background = 'transparent';
				}
			});
		}
	}

	document.addEventListener('DOMContentLoaded', initFontSize);
	document.addEventListener('astro:page-load', initFontSize);
</script>
